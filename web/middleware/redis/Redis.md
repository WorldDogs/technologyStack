# Redis

## 备份与恢复

### RDB

- 定义

	- 内存快照，将内存中的某一刻的数据记录到磁盘中

- 优势

	- 恢复速度更快
	- 文件紧凑，便于传输和灾难恢复
	- 子主题 3

### AOF

- 定义

	- Append Only File
	- 是一种写后日志，即当命令执行完成后采用追加的方式记录日志

- 写回策略

	- Always

		- 执行完命令 立刻写日志
		- 缺点

			- 会阻塞当前当前写操作

	- everysec 

		- 执行完命令，先写入AOF缓存(内存)，每秒将缓存写回到磁盘

	- no

		- 相对于everysec，它是由系统决定何时进行写回

- AOF重写机制

	- 出发点

		- 避免AOF文件太大：

			- 系统无法保存
			- 因为文件大而导致的写回效率变低
			- 宕机后恢复慢

	- 解决方案

		- 通过重写当前最新数据成AOF文件，来使得原先对同一个键的多个操作合并为了一个，减少了AOF日志数量
		- 

- 实践

### 实践

- RDB备份与恢复

	- 开启
	- 备份命令

		- save

			- 主线程执行，会阻塞，客户端无法连接

		- bgsave

			- 子进程备份

	- 恢复

		- 1.获取备份文件目录

			- CONFIG GET dir

		- 2.将dump.rdb文件放入1中目录
		- 3.启动redis服务

- aof备份与恢复

	- 开启

		- config set appendonly yes

	- 配置

		- 配置文件或者命令

	- 恢复

		- 同RDB恢复(只是文件换成了appendonly.aof)

- aof和rdb

## 数据结构

### string

### hash

- 相关命令

	- hget

		-  hget dev01:temperature 202012170914

	- hmget

	  获取多个hash键

		-  HMGET dev01:temperature 202012170813 202012170914
		- 获取hash 多个键对应的值

	- hmset

	  增加多个hash键值

		- hmset wd 1 23 2 24 3 25
		- 设置多个hash 键值

	- hgetall

	  获取hash中所有键值对

		- 获取hash 所有的键值

	- HINCRBY

	  给key的某个字段增加***

		- 字段增加值

	- hkeys

		- 获取所有字段

	- hvals

		- 获取所有值

	- hsetnx

		- 字段不存在时设置

	- hscan

		- 使用场景

			- 海量数据查询时，会导致阻塞主线程，所以不能直接hkeys,hvals这种操作，hscan是基于游标的查询

### list

### set

- 集合

	- 支持各种集合操作

### sorted set

- zadd
- zcount

	- 根据score 统计

### hyperloglog

### GEO

### steam

### set

- sorted list
- 集合，元素唯一

### 数据结构与底层实现 - 图

- 

## 发布订阅

### 支持pattern 订阅

## 事务

### multi

- 开始原子操作，以后输入的命令都会进入队列，但不执行

### exec

- 执行内部队列的所有命令

### tips

- multi过后，如果出现错误，还是能正长执行后续命令，但是exec的时候会报错

## 实践

### 时序数据存储

- sorted set 实现

	- 优点

		- 可以排序 聚合运算

- hash实现

	- 优点
	- 缺点

- redisTimeSeries

## 消息队列

### 需要满足的条件

- 消息保序

	- 产品库存如果失序的话，会存在严重问题

- 重复消息处理

	- 幂等：同一条消息收到一次和收到多次，最终的结果应该是一样的。

- 可靠性保证

	- 故障、宕机后能恢复数据

- 图

	- 

### 实现方案

- 基于list

	- 缺点

		- 不能并发消费

	- brpoplpush

		- 保证阻塞型消费，没有数据时减少cpu资源占用
		- 消息取走后，如果消费方处理不当，可以再次拿到数据

- 基于steam

	- 优点

		- 可以并发消费，是redis专门为消息队列提供的解决方案

	- 相关命令

		- XADD mqstream * repo 5

			- * 让系统生成唯一id，也可以自己设置

		- 子主题 2

			- XREAD block 10000 streams mqstream $

				- block 后跟阻塞时间，ms单位，$代表从哪开始取，可以指定id

## 配置

### 内存分配

- 获取

	- config get maxmemory 

- 配置redis占用

	- config set maxmemory X

## 数据清理

### 清空所有库得所有key

- flushall

### 清空当前库

- flushdb

## 淘汰策略

内存毕竟算是稀缺资源，所以总会有满得时候，当满了后，再来新的数据，就会有数据被淘汰，具体如何淘汰，这就是淘汰策略。
如果设置的最大内存(config set memory)值小于当前已经占用内存(info memory),不会将已有数据进行淘汰

### 不淘汰已经存在数据

- noevition

	- 新得写请求过来，会直接报错

### 淘汰已经存在数据

- 在设置过期时间数据中进行淘汰

	- valitile-random
	- volatile-ttl
	- volatile-lru
	- volatile-lfu

- 在所有数据中淘汰

	- allkeys-lru
	- allkeys-random
	- allkeys-lfu

## 缓存污染

不再访问的数据，仍然在缓存中占用空间，这部分数据被称为缓存污染

### 子主题 1

## 实践

### 缓存雪崩

缓存雪崩是大量数据同时失效

- [成因1]缓存在同一时间内大批量过期，导致大量请求无法在缓存层处理，打到了数据库层，进而把数据库打崩的情况

	- 解决方案

		- 增加随机额外随机过期时间
		- 服务降级，非核心数据采用直接返回错误或者返回模板数据，核心数据放行处理

- redis实例宕机

	- 解决方案

		- 进行服务熔断，即当发生缓存雪崩时，为了防止引发连锁数据库崩溃，暂定缓存接口的服务，

- 宕机和同时过期通用·处理

	- 限流

		- 一旦检测到雪崩，只允许每秒进入系统的请求数为n/s

### 缓存击穿

热点数据请求，无法在缓存中处理，大批量打到数据库给打崩了

### 缓存穿透

访问的数据 即不在缓存中也不再数据库中

- 场景

	- 数据误删除
	- 恶意攻击

- 解决方案

	- 缓存空值或缺省值
	- 布隆过滤器判断数据是否存在

### 总结

- 缓存雪崩，缓存击穿为数据不在缓存中，而缓存穿透则是数据不在缓存和数据库中
- 

## 原子操作

### lua脚本

redis 会把lua脚本作为整体执行，执行过程不会被其他命令打断

### 合并型命令

- incr
- desc

## 优先级

### 使用

### 运维

### 原理

